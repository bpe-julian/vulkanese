#version 450
#extension GL_EXT_shader_explicit_arithmetic_types_float64 : enable
//#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable
#extension GL_ARB_separate_shader_objects : enable
        #define POLYPHONY 64
#define POLYPHONY_PER_SHADER 2
#define SHADERS_PER_TIMESLICE 32
#define PARTIALS_PER_VOICE 8
#define MINIMUM_FREQUENCY_HZ 20
#define MAXIMUM_FREQUENCY_HZ 20000
#define SAMPLE_FREQUENCY 44100
#define UNDERVOLUME 3
#define CHANNELS 1
#define SAMPLES_PER_DISPATCH 64
#define LATENCY_SECONDS 0.01
#define ENVELOPE_LENGTH 256
#define FILTER_STEPS 2048
layout (local_size_x = 1, local_size_y = PARTIALS_PER_VOICE, local_size_z = 1 ) in;
layout(std140, set = 0, binding = 0) buffer pcmBufferOut_buf
{
   float pcmBufferOut[8192];
};
layout(std140, set = 1, binding = 1) uniform noteBasePhase_buf
{
   float64_t noteBasePhase[512];
};
layout(std140, set = 1, binding = 2) uniform noteBaseIncrement_buf
{
   float noteBaseIncrement[256];
};
layout(std140, set = 1, binding = 3) uniform partialMultiplier_buf
{
   float partialMultiplier[32];
};
layout(std140, set = 1, binding = 4) uniform partialVolume_buf
{
   float partialVolume[32];
};
layout(std140, set = 1, binding = 5) uniform noteVolume_buf
{
   float noteVolume[256];
};
layout(std140, set = 1, binding = 6) uniform noteStrikeTime_buf
{
   float64_t noteStrikeTime[512];
};
layout(std140, set = 1, binding = 7) uniform noteReleaseTime_buf
{
   float64_t noteReleaseTime[512];
};
layout(std140, set = 1, binding = 8) uniform currTime_buf
{
   float64_t currTime[512];
};
layout(std140, set = 1, binding = 9) uniform attackEnvelope_buf
{
   float attackEnvelope[1024];
};
layout(std140, set = 1, binding = 10) uniform releaseEnvelope_buf
{
   float releaseEnvelope[1024];
};
layout(std140, set = 1, binding = 11) uniform envelopeSpeedMultiplier_buf
{
   float envelopeSpeedMultiplier[256];
};
layout(std140, set = 1, binding = 12) uniform freqFilter_buf
{
   float freqFilter[8192];
};
layout(std140, set = 1, binding = 13) uniform pitchFactor_buf
{
   float pitchFactor[256];
};

        void main() {

          uint polySlice = gl_GlobalInvocationID.x;
          uint timeSlice = gl_GlobalInvocationID.y;

          float sum = 0;
          
          for (uint noteNo = polySlice*POLYPHONY_PER_SHADER; noteNo<(polySlice+1)*POLYPHONY_PER_SHADER; noteNo++){
          
              // calculate the envelope 
              // time is a float holding seconds (since epoch?)
              // these values are updated in the python loop
              float env = 0;
              int envelopeIndex;
              float64_t envelopeIndexFloat64;
              
              // attack phase
              float64_t secondsSinceStrike  = abs(currTime[0] - noteStrikeTime[noteNo] );
              float64_t secondsSinceRelease = abs(currTime[0] - noteReleaseTime[noteNo]);
              
              // attack phase
              if(noteStrikeTime[noteNo] > noteReleaseTime[noteNo]){
                envelopeIndexFloat64 = secondsSinceStrike*envelopeSpeedMultiplier[noteNo];
                // keep the fractional part, for interp
                float64_t fractional = mod(envelopeIndexFloat64, envelopeIndex);
                
                // if envelope is complete, maintain at the final index
                if(envelopeIndex >= ENVELOPE_LENGTH)
                    env = attackEnvelope[ENVELOPE_LENGTH-1];
                // otherwise, linear interp the envelope
                else
                    env = attackEnvelope[envelopeIndex];
                
              }
              // release phase
              else{
                envelopeIndexFloat64 = secondsSinceRelease*envelopeSpeedMultiplier[noteNo];
                // keep the fractional part, for interp
                float64_t fractional = mod(envelopeIndexFloat64, envelopeIndex);
                // if envelope is complete, maintain at the final index
                if(envelopeIndex >= ENVELOPE_LENGTH)
                    env = releaseEnvelope[ENVELOPE_LENGTH-1];
                // otherwise, linear interp the envelope
                else
                    env = releaseEnvelope[envelopeIndex];
              }
              
              // the note volume is given, and env is applied as well
              float noteVol = noteVolume[noteNo] * env;
              
              
              float increment = noteBaseIncrement[noteNo]*pitchFactor[0];
              float64_t phase = noteBasePhase[noteNo] + (timeSlice * increment);

              float innersum = 0;
              for (uint partialNo = 0; partialNo<PARTIALS_PER_VOICE; partialNo++)
              {
                float vol = partialVolume[partialNo];

                float harmonicRatio   = partialMultiplier[partialNo];
                float thisIncrement = increment * harmonicRatio;
                
                if(thisIncrement < 3.14){
                    int indexInFilter = int(thisIncrement*(FILTER_STEPS/(3.14)));
                    innersum += vol * sin(float(phase)*harmonicRatio) * freqFilter[indexInFilter];
                }

              }
              sum+=innersum*noteVol;
          }
          
          pcmBufferOut[timeSlice*SHADERS_PER_TIMESLICE + polySlice] = sum/64;//(PARTIALS_PER_VOICE*POLYPHONY);
        }
        