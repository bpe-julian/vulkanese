#version 450
        #extension GL_ARB_separate_shader_objects : enable
        #define POLYPHONY 128
#define PARTIALS_PER_VOICE 256
#define MINIMUM_FREQUENCY_HZ 20
#define MAXIMUM_FREQUENCY_HZ 20000
#define SAMPLE_FREQUENCY 44100
#define UNDERVOLUME 3
#define CHANNELS 1
#define SAMPLES_PER_DISPATCH 64
#define LATENCY_SECONDS 0.1
layout (local_size_x = 1, local_size_y = PARTIALS_PER_VOICE, local_size_z = 1 ) in;
layout(std140, set = 0, binding = 0) buffer pcmBufferOut_buf
{
   float pcmBufferOut[256];
};
layout(std140, set = 1, binding = 1) uniform noteBasePhase_buf
{
   float noteBasePhase[512];
};
layout(std140, set = 1, binding = 2) uniform noteBaseIncrement_buf
{
   float noteBaseIncrement[512];
};
layout(std140, set = 1, binding = 3) uniform partialMultiplier_buf
{
   float partialMultiplier[1024];
};
layout(std140, set = 1, binding = 4) uniform partialVolume_buf
{
   float partialVolume[512];
};
layout(std140, set = 1, binding = 5) uniform noteVolume_buf
{
   float noteVolume[512];
};


        void main() {

          uint timeSlice = gl_GlobalInvocationID.y;

          float sum = 0;
          
          for (uint noteNo = 0; noteNo<POLYPHONY; noteNo++){
              float noteVol = noteVolume[noteNo];
              float increment = noteBaseIncrement[noteNo];
              float phase = noteBasePhase[noteNo] + (timeSlice * increment);

              float innersum = 0;
              for (uint partialNo = 0; partialNo<PARTIALS_PER_VOICE; partialNo++)
              {
                float vol = partialVolume[partialNo];

                float harmonicRatio   = partialMultiplier[partialNo];
                innersum += vol * sin(phase*harmonicRatio);

              }
              sum+=innersum*noteVol;
          }
          
          pcmBufferOut[timeSlice] = sum/(PARTIALS_PER_VOICE*POLYPHONY);
        }
        