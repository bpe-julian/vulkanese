#version 450
        #extension GL_ARB_separate_shader_objects : enable
        #define POLYPHONY 128
#define SINES_PER_VOICE 128
#define MINIMUM_FREQUENCY_HZ 20
#define MAXIMUM_FREQUENCY_HZ 20000
#define SAMPLE_FREQUENCY 44100
#define UNDERVOLUME 3
#define CHANNELS 1
#define SAMPLES_PER_DISPATCH 128
#define LATENCY_SECONDS 0.1
layout (local_size_x = 1, local_size_y = SINES_PER_VOICE, local_size_z = 1 ) in;
layout(std140, set = 0, binding = 0) buffer pcmBufferOut_buf
{
   float pcmBufferOut[65536];
};
layout(std140, set = 1, binding = 1) uniform phaseBuffer_buf
{
   float phaseBuffer[65536];
};
layout(std140, set = 1, binding = 2) uniform baseIncrement_buf
{
   float baseIncrement[512];
};
layout(std140, set = 1, binding = 3) uniform harmonicMultiplier_buf
{
   float harmonicMultiplier[512];
};
layout(std140, set = 1, binding = 4) uniform harmonicsVolume_buf
{
   float harmonicsVolume[512];
};


        void main() {

          /*
          In order to fit the work into workgroups, some unnecessary threads are launched.
          We terminate those threads here.
          if(gl_GlobalInvocationID.x >= 0 || gl_GlobalInvocationID.y >= 0)
            return;
          */

          uint noteNo = gl_GlobalInvocationID.x;
          uint timeSlice = gl_GlobalInvocationID.y;

          uint outindex = 0;
          float sum = 0;

          for (int noteNo = 0; noteNo<POLYPHONY; noteNo++)
          {
              float increment = baseIncrement[noteNo];
              float phase = phaseBuffer[outindex] + (timeSlice * increment);
              float vol = harmonicsVolume[noteNo];
              for (int sineNo = 0; sineNo<SINES_PER_VOICE; sineNo++)
              {

                float harmonicRatio   = harmonicMultiplier[sineNo];
                sum += vol * sin(phase*harmonicRatio)/(SINES_PER_VOICE*POLYPHONY);

              }
          }
          
          pcmBufferOut[noteNo*SAMPLES_PER_DISPATCH + timeSlice] = sum;
        }
        