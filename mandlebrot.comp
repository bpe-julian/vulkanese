#version 450
#extension GL_EXT_shader_explicit_arithmetic_types_float64 : enable
//#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable
#extension GL_ARB_separate_shader_objects : enable
        #define POLYPHONY 4
#define PARTIALS_PER_VOICE 2
#define MINIMUM_FREQUENCY_HZ 20
#define MAXIMUM_FREQUENCY_HZ 20000
#define SAMPLE_FREQUENCY 44100
#define UNDERVOLUME 3
#define CHANNELS 1
#define SAMPLES_PER_DISPATCH 64
#define LATENCY_SECONDS 0.01
#define FILTER_STEPS 2048
layout (local_size_x = 1, local_size_y = PARTIALS_PER_VOICE, local_size_z = 1 ) in;
layout(std140, set = 0, binding = 0) buffer pcmBufferOut_buf
{
   float pcmBufferOut[256];
};
layout(std140, set = 1, binding = 1) uniform noteBasePhase_buf
{
   float noteBasePhase[16];
};
layout(std140, set = 1, binding = 2) uniform noteBaseIncrement_buf
{
   float noteBaseIncrement[16];
};
layout(std140, set = 1, binding = 3) uniform partialMultiplier_buf
{
   float partialMultiplier[8];
};
layout(std140, set = 1, binding = 4) uniform partialVolume_buf
{
   float partialVolume[8];
};
layout(std140, set = 1, binding = 5) uniform noteVolume_buf
{
   float noteVolume[16];
};
layout(std140, set = 1, binding = 6) uniform noteStrikeTime_buf
{
   float64_t noteStrikeTime[32];
};
layout(std140, set = 1, binding = 7) uniform noteReleaseTime_buf
{
   float64_t noteReleaseTime[32];
};
layout(std140, set = 1, binding = 8) uniform currTime_buf
{
   float64_t currTime[16];
};
layout(std140, set = 1, binding = 9) uniform envelopeParams_buf
{
   float envelopeParams[16];
};
layout(std140, set = 1, binding = 10) uniform freqFilter_buf
{
   float freqFilter[8192];
};
layout(std140, set = 1, binding = 11) uniform pitchFactor_buf
{
   float pitchFactor[16];
};

        void main() {

          uint timeSlice = gl_GlobalInvocationID.y;

          float sum = 0;
          
          for (uint noteNo = 0; noteNo<POLYPHONY; noteNo++){
              float noteVol = noteVolume[noteNo];
              float increment = noteBaseIncrement[noteNo]*pitchFactor[0];
              float phase = noteBasePhase[noteNo] + (timeSlice * increment);

              float innersum = 0;
              for (uint partialNo = 0; partialNo<PARTIALS_PER_VOICE; partialNo++)
              {
                float vol = partialVolume[partialNo];

                float harmonicRatio   = partialMultiplier[partialNo];
                float thisIncrement = increment * harmonicRatio;
                
                if(thisIncrement < 3.14){
                    int indexInFilter = int(thisIncrement*(FILTER_STEPS/(3.14)));
                    innersum += vol * sin(phase*harmonicRatio) * freqFilter[indexInFilter];
                }

              }
              sum+=innersum*noteVol;
          }
          
          pcmBufferOut[timeSlice] = sum/64;//(PARTIALS_PER_VOICE*POLYPHONY);
        }
        